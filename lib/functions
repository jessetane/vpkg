#!/usr/bin/env bash
#
# vpkg
#
# the functions in this file should
# never be called directly - always
# use the form: "vpkg-<command>"
#

# public functions
__vpkg_exports="version
                lookup
                install
                uninstall
                link
                unlink
                use
                unuse"

# expose public functions as: vpkg-<command>
for __vpkg_export in __vpkg_exports
do
  eval "vpkg-$__vpkg_export() {
    __vpkg_module \"__vpkg_$__vpkg_export\" "'"$@"'"; 
  }"
done

# private module scope
__vpkg_module() {
  
  # args
  local cmd="$1"
  local name="$2"
  local version="$3"
  local sourceVersion="$4"
  
  # these could probably be hardcoded..
  local vpkg_hook_file="vpkgfile"
  local vpkg_link_name="current"
  
  # vars
  local pkg="$VPKG_ROOT"/lib/"$name"
  local src="$pkg"/src
  local versions="$pkg"/versions
  local bin="$versions/$version"/bin
  
  # common validation
  if [ "$cmd" != "__vpkg_version" ] 
  then
    [ -z "$VPKG_ROOT" ] && echo '$VPKG_ROOT must be defined' >&2 && return 1
    [ -z "$name" ] && echo "please specify a package name" >&2 && return 1
    [ -n "$version" ] && [ "$version" = "$vpkg_link_name" ] && echo "$vpkg_link_name is a reserved version name" >&2 && return 1
  fi
  
  # proxy to command
  "$cmd" "${@:2}"
}

__vpkg_version() {
  echo "0.0.2"
}

__vpkg_lookup() {
  
  # TODO: lookup formula location from a package registry?
  # formula_location=""
  
  # manually input a formula location
  while [ -z "$formula_location" ]
  do
    { read -p "no formula found for $name, type a url: " formula_location; }
  done
  
  # 
  echo "$formula_location"
}

__vpkg_install() {
  
  # if we don't have any source files
  # we should try to lookup a vpkg_hook_file
  if [ ! -e "$src" ] || [ -z "$(ls "$src")" ]
  then
    url="$(vpkg-lookup "$name")"
    mkdir -p "$src"
    echo "downloading $url..."
    curl -f# "$url" -o "$src"/"$vpkg_hook_file"
    [ $? != 0 ] && rm -rf "$pkg" && exit 1
  fi
  
  # ensure we have a versions dir
  mkdir -p "$versions"
  
  # only allow unspecified version if we don't have any versions already installed
  if [ -z "$version" ]
  then
    local installed="$(ls "$versions")"
    [ -n "$installed" ] && echo -e "version(s): $installed are already installed" >&2 && return 0
  
  # if version was specified, check to be sure it doesn't exist
  elif [ -e "$versions"/"$version" ]
  then
    echo "version $version is already installed" >&2 && return 1
  fi
  
  # uninstall and unlink any old versions
  vpkg-uninstall "$name" "$version" > /dev/null 2>&1
  
  # install
  (
    # fallback
    install() {
      
      # require version
      [ -z "$version" ] && echo "please specify a version" >&2 && exit 1
      
      # just copy the src over into versions
      cp -R "$src" "$versions"/"$version"
    }
    
    # source hooks 
    source "$src"/"$vpkg_hook_file"
    install "$@"
  )
}

__vpkg_uninstall() {
  
  # validate
  [ -z "$version" ] && echo "please specify a version" >&2 && return 1
  
  # unlink if necessary
  vpkg-unlink "$name" "$version" > /dev/null 2>&1
  
  # uninstall
  (
    # fallback
    uninstall() {
      
      # just copy the src over into versions
      rm -rf "$versions"/"$version"
    }
    
    # source hooks
    source "$src"/"$vpkg_hook_file"
    uninstall "$@"
  )
}

__vpkg_link() {
  
  # validate
  [ -z "$version" ] && echo "please specify a version" >&2 && return 1
  [ ! -e "$versions"/"$version" ] && echo "version $version is not installed" >&2 && return 1
  
  # unlink
  vpkg-unlink "$name" > /dev/null 2>&1
  
  # create link
  ln -s "$versions"/"$version" "$versions"/"$vpkg_link_name"
  
  # create executables
  local executable
  ls "$bin" | while read executable
  do
    
    # link via exec
    local dest="$VPKG_ROOT"/bin/"$executable"
    echo "exec $bin/$executable "'$@' > "$dest"
    chmod +x "$dest"
  done
}

__vpkg_unlink() {
  local old_link="$(readlink "$versions"/"$vpkg_link_name")"
  
  # if a version was specified, check to ensure that version is actually linked
  if [ -n "$version" ] && [ "$old_link" != "$versions"/"$version" ]
  then
    echo "version $version is not linked" >&2
    return 1
  fi
  
  # remove link
  rm -rf "$versions"/"$vpkg_link_name"
  
  # remove old executables
  ls "$old_link"/bin | while read bin
  do
    rm -rf "$VPKG_ROOT"/bin/"$bin"
  done
}

__vpkg_use() {

  # validate
  [ -z "$version" ] && echo "please specify a version" >&2 && return 1
  [ ! -e "$bin" ] && echo "version $version is not installed" >&2 && return 1

  # unuse old versions
  vpkg-unuse "$name"

  # use new version
  export PATH="$bin":$PATH
}

__vpkg_unuse() {

  # if version wasn't specified, match any
  [ -z "$version" ] && version="[^/]*"
  
  # remove all old versions
  export PATH="$(echo "$PATH" | sed "s|$versions/$version/bin:||g")"
}
